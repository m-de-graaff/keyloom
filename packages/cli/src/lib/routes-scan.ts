import fs from 'node:fs'
import path from 'node:path'

export interface GenerateRoutesOptions {
  cwd?: string
  out?: string
  outJson?: string
}

export interface GenerateRoutesResult {
  count: number
  outTs: string
  outJson: string
}

export async function generateRoutes(
  opts: GenerateRoutesOptions = {},
): Promise<GenerateRoutesResult> {
  const cwd = opts.cwd || process.cwd()
  const outTs = opts.out
    ? path.resolve(cwd, opts.out)
    : path.join(cwd, '.keyloom', 'routes.generated.ts')
  const outJson = opts.outJson
    ? path.resolve(cwd, opts.outJson)
    : path.join(cwd, '.keyloom', 'routes.generated.json')

  // Ensure output directory exists
  fs.mkdirSync(path.dirname(outTs), { recursive: true })
  fs.mkdirSync(path.dirname(outJson), { recursive: true })

  const entries: any[] = []

  // Scan app directory (Next.js App Router)
  const appDir = path.join(cwd, 'app')
  if (fs.existsSync(appDir)) {
    scanDirectory(appDir, 'app', entries)
  }

  // Scan pages directory (Next.js Pages Router)
  const pagesDir = path.join(cwd, 'pages')
  if (fs.existsSync(pagesDir)) {
    scanDirectory(pagesDir, 'pages', entries)
  }

  // Generate manifest
  const manifest = {
    generatedAt: new Date().toISOString(),
    entries,
  }

  // Write JSON manifest
  fs.writeFileSync(outJson, JSON.stringify(manifest, null, 2))

  // Write TypeScript file
  const tsContent = `// Generated by keyloom routes command
import type { KeyloomRoutesManifest } from '@keyloom/nextjs/route-types'

const manifest: KeyloomRoutesManifest = ${JSON.stringify(manifest, null, 2)}

export default manifest
export const routes = manifest.entries
`
  fs.writeFileSync(outTs, tsContent)

  return {
    count: entries.length,
    outTs,
    outJson,
  }
}

function scanDirectory(dir: string, type: 'app' | 'pages', entries: any[]) {
  const files = fs.readdirSync(dir, { withFileTypes: true })

  for (const file of files) {
    const fullPath = path.join(dir, file.name)

    if (file.isDirectory()) {
      scanDirectory(fullPath, type, entries)
    } else if (file.isFile() && (file.name.endsWith('.tsx') || file.name.endsWith('.ts'))) {
      const content = fs.readFileSync(fullPath, 'utf8')
      const keyloomExport = extractKeyloomExport(content)

      if (keyloomExport) {
        const pattern = getRoutePattern(fullPath, type)
        entries.push({
          pattern,
          rule: keyloomExport,
          file: fullPath,
          specificity: calculateSpecificity(pattern),
        })
      }
    }
  }
}

function extractKeyloomExport(content: string): any {
  // Simple regex to extract keyloom export
  const match = content.match(/export\s+const\s+keyloom\s*=\s*({[^}]*})/s)
  if (match) {
    try {
      // Remove 'as const' if present
      let cleanedMatch = match[1] ? match[1].replace(/\s+as\s+const\s*$/, '') : ''
      // Attempt to convert JS object literal to JSON
      cleanedMatch = cleanedMatch
        .replace(/([a-zA-Z0-9_]+)\s*:/g, '"$1":') // quote keys
        .replace(/'/g, '"') // single to double quotes
      return JSON.parse(cleanedMatch)
    } catch {
      return null
    }
  }
  return null
}

function getRoutePattern(filePath: string, type: 'app' | 'pages'): string {
  const relativePath = path.relative(process.cwd(), filePath)
  let routePath = relativePath
    .replace(/^(app|pages)\//, '')
    .replace(/\.(tsx?|jsx?)$/, '')
    .replace(/\/page$/, '')
    .replace(/\/index$/, '')

  if (type === 'pages' && routePath.includes('api/')) {
    routePath = routePath.replace('api/', '/api/')
  }

  // Handle dynamic routes
  routePath = routePath.replace(/\[([^\]]+)\]/g, '[$1]')

  return routePath.startsWith('/') ? routePath : `/${routePath}`
}

function calculateSpecificity(pattern: string): number {
  let specificity = 0
  const segments = pattern.split('/').filter(Boolean)

  for (const segment of segments) {
    if (segment.startsWith('[') && segment.endsWith(']')) {
      specificity += 1 // Dynamic segment
    } else {
      specificity += 10 // Static segment
    }
  }

  return specificity
}
