import fs from 'node:fs'
import path from 'node:path'

export interface GenerateRoutesOptions {
  cwd?: string
  out?: string
  outJson?: string
}

export interface GenerateRoutesResult {
  count: number
  outTs: string
  outJson: string
}

export async function generateRoutes(
  opts: GenerateRoutesOptions = {},
): Promise<GenerateRoutesResult> {
  const cwd = opts.cwd || process.cwd()
  const outTs = opts.out
    ? path.resolve(cwd, opts.out)
    : path.join(cwd, '.keyloom', 'routes.generated.ts')
  const outJson = opts.outJson
    ? path.resolve(cwd, opts.outJson)
    : path.join(cwd, '.keyloom', 'routes.generated.json')

  fs.mkdirSync(path.dirname(outTs), { recursive: true })
  fs.mkdirSync(path.dirname(outJson), { recursive: true })

  const entries: any[] = []

  const appDir = path.join(cwd, 'app')
  if (fs.existsSync(appDir)) {
    scanDirectory(appDir, 'app', entries, cwd)
  }

  const pagesDir = path.join(cwd, 'pages')
  if (fs.existsSync(pagesDir)) {
    scanDirectory(pagesDir, 'pages', entries, cwd)
  }

  const manifest = {
    generatedAt: new Date().toISOString(),
    entries,
  }

  fs.writeFileSync(outJson, JSON.stringify(manifest, null, 2))

  const tsContent = `// Generated by keyloom routes command
import type { KeyloomRoutesManifest } from '@keyloom/nextjs/route-types'

const manifest: KeyloomRoutesManifest = ${JSON.stringify(manifest, null, 2)}

export default manifest
export const routes = manifest.entries
`
  fs.writeFileSync(outTs, tsContent)

  return {
    count: entries.length,
    outTs,
    outJson,
  }
}

function scanDirectory(
  dir: string,
  type: 'app' | 'pages',
  entries: any[],
  root: string,
) {
  const files = fs.readdirSync(dir, { withFileTypes: true })

  for (const file of files) {
    const fullPath = path.join(dir, file.name)

    if (file.isDirectory()) {
      scanDirectory(fullPath, type, entries, root)
      continue
    }

    if (!file.isFile()) continue
    if (!/\.(tsx?|jsx?)$/i.test(file.name)) continue

    const content = fs.readFileSync(fullPath, 'utf8')
    const keyloomExport = extractKeyloomExport(content)

    if (!keyloomExport) continue

    const relative = toPosix(path.relative(root, fullPath))
    const pattern = getRoutePattern(relative, type)

    entries.push({
      pattern,
      rule: keyloomExport,
      file: fullPath,
      specificity: calculateSpecificity(pattern),
    })
  }
}

function extractKeyloomExport(content: string): any {
  const match = content.match(/export\s+const\s+keyloom\s*=\s*({[^}]*})/s)
  if (!match) return null

  try {
    let cleanedMatch = match[1] ? match[1].replace(/\s+as\s+const\s*$/, '') : ''
    cleanedMatch = cleanedMatch
      .replace(/([a-zA-Z0-9_]+)\s*:/g, '"$1":')
      .replace(/'/g, '"')
    return JSON.parse(cleanedMatch)
  } catch {
    return null
  }
}

function getRoutePattern(relativePath: string, type: 'app' | 'pages'): string {
  const normalized = toPosix(relativePath)
  let routePath = normalized.replace(/^(app|pages)\//, '')

  routePath = routePath.replace(/\.(tsx?|jsx?)$/i, '')
  if (type === 'app') {
    routePath = routePath.replace(/\/(route|page)$/i, '')
  }
  routePath = routePath.replace(/\/index$/i, '')

  if (!routePath || routePath === '') {
    return '/'
  }

  return routePath.startsWith('/') ? routePath : `/${routePath}`
}

function toPosix(p: string): string {
  return p.split(path.sep).join('/')
}

function calculateSpecificity(pattern: string): number {
  let specificity = 0
  const segments = pattern.split('/').filter(Boolean)

  for (const segment of segments) {
    if (segment.startsWith('[') && segment.endsWith(']')) {
      specificity += 1
    } else {
      specificity += 10
    }
  }

  return specificity
}